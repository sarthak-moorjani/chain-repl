// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chain.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chain_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chain_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chain_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chain_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chain_2eproto;
namespace chain {
class AckArg;
struct AckArgDefaultTypeInternal;
extern AckArgDefaultTypeInternal _AckArg_default_instance_;
class AckRet;
struct AckRetDefaultTypeInternal;
extern AckRetDefaultTypeInternal _AckRet_default_instance_;
class FwdArg;
struct FwdArgDefaultTypeInternal;
extern FwdArgDefaultTypeInternal _FwdArg_default_instance_;
class FwdRet;
struct FwdRetDefaultTypeInternal;
extern FwdRetDefaultTypeInternal _FwdRet_default_instance_;
class GetArg;
struct GetArgDefaultTypeInternal;
extern GetArgDefaultTypeInternal _GetArg_default_instance_;
class GetRet;
struct GetRetDefaultTypeInternal;
extern GetRetDefaultTypeInternal _GetRet_default_instance_;
class PutArg;
struct PutArgDefaultTypeInternal;
extern PutArgDefaultTypeInternal _PutArg_default_instance_;
class PutRet;
struct PutRetDefaultTypeInternal;
extern PutRetDefaultTypeInternal _PutRet_default_instance_;
}  // namespace chain
PROTOBUF_NAMESPACE_OPEN
template<> ::chain::AckArg* Arena::CreateMaybeMessage<::chain::AckArg>(Arena*);
template<> ::chain::AckRet* Arena::CreateMaybeMessage<::chain::AckRet>(Arena*);
template<> ::chain::FwdArg* Arena::CreateMaybeMessage<::chain::FwdArg>(Arena*);
template<> ::chain::FwdRet* Arena::CreateMaybeMessage<::chain::FwdRet>(Arena*);
template<> ::chain::GetArg* Arena::CreateMaybeMessage<::chain::GetArg>(Arena*);
template<> ::chain::GetRet* Arena::CreateMaybeMessage<::chain::GetRet>(Arena*);
template<> ::chain::PutArg* Arena::CreateMaybeMessage<::chain::PutArg>(Arena*);
template<> ::chain::PutRet* Arena::CreateMaybeMessage<::chain::PutRet>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chain {

// ===================================================================

class PutArg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chain.PutArg) */ {
 public:
  inline PutArg() : PutArg(nullptr) {}
  ~PutArg() override;
  explicit PROTOBUF_CONSTEXPR PutArg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutArg(const PutArg& from);
  PutArg(PutArg&& from) noexcept
    : PutArg() {
    *this = ::std::move(from);
  }

  inline PutArg& operator=(const PutArg& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutArg& operator=(PutArg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutArg& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutArg* internal_default_instance() {
    return reinterpret_cast<const PutArg*>(
               &_PutArg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PutArg& a, PutArg& b) {
    a.Swap(&b);
  }
  inline void Swap(PutArg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutArg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutArg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutArg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutArg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutArg& from) {
    PutArg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutArg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chain.PutArg";
  }
  protected:
  explicit PutArg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValFieldNumber = 2,
    kSourceIpFieldNumber = 3,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string val = 2;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const std::string& val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_val();
  PROTOBUF_NODISCARD std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // optional string source_ip = 3;
  bool has_source_ip() const;
  private:
  bool _internal_has_source_ip() const;
  public:
  void clear_source_ip();
  const std::string& source_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_ip();
  PROTOBUF_NODISCARD std::string* release_source_ip();
  void set_allocated_source_ip(std::string* source_ip);
  private:
  const std::string& _internal_source_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_ip(const std::string& value);
  std::string* _internal_mutable_source_ip();
  public:

  // @@protoc_insertion_point(class_scope:chain.PutArg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_ip_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chain_2eproto;
};
// -------------------------------------------------------------------

class PutRet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chain.PutRet) */ {
 public:
  inline PutRet() : PutRet(nullptr) {}
  ~PutRet() override;
  explicit PROTOBUF_CONSTEXPR PutRet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutRet(const PutRet& from);
  PutRet(PutRet&& from) noexcept
    : PutRet() {
    *this = ::std::move(from);
  }

  inline PutRet& operator=(const PutRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutRet& operator=(PutRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutRet* internal_default_instance() {
    return reinterpret_cast<const PutRet*>(
               &_PutRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PutRet& a, PutRet& b) {
    a.Swap(&b);
  }
  inline void Swap(PutRet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutRet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutRet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutRet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutRet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutRet& from) {
    PutRet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutRet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chain.PutRet";
  }
  protected:
  explicit PutRet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
  };
  // optional string val = 1;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const std::string& val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_val();
  PROTOBUF_NODISCARD std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // @@protoc_insertion_point(class_scope:chain.PutRet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chain_2eproto;
};
// -------------------------------------------------------------------

class FwdArg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chain.FwdArg) */ {
 public:
  inline FwdArg() : FwdArg(nullptr) {}
  ~FwdArg() override;
  explicit PROTOBUF_CONSTEXPR FwdArg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FwdArg(const FwdArg& from);
  FwdArg(FwdArg&& from) noexcept
    : FwdArg() {
    *this = ::std::move(from);
  }

  inline FwdArg& operator=(const FwdArg& from) {
    CopyFrom(from);
    return *this;
  }
  inline FwdArg& operator=(FwdArg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FwdArg& default_instance() {
    return *internal_default_instance();
  }
  static inline const FwdArg* internal_default_instance() {
    return reinterpret_cast<const FwdArg*>(
               &_FwdArg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FwdArg& a, FwdArg& b) {
    a.Swap(&b);
  }
  inline void Swap(FwdArg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FwdArg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FwdArg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FwdArg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FwdArg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FwdArg& from) {
    FwdArg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FwdArg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chain.FwdArg";
  }
  protected:
  explicit FwdArg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValFieldNumber = 2,
    kSourceIpFieldNumber = 3,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string val = 2;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const std::string& val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_val();
  PROTOBUF_NODISCARD std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // optional string source_ip = 3;
  bool has_source_ip() const;
  private:
  bool _internal_has_source_ip() const;
  public:
  void clear_source_ip();
  const std::string& source_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_ip();
  PROTOBUF_NODISCARD std::string* release_source_ip();
  void set_allocated_source_ip(std::string* source_ip);
  private:
  const std::string& _internal_source_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_ip(const std::string& value);
  std::string* _internal_mutable_source_ip();
  public:

  // @@protoc_insertion_point(class_scope:chain.FwdArg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_ip_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chain_2eproto;
};
// -------------------------------------------------------------------

class FwdRet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chain.FwdRet) */ {
 public:
  inline FwdRet() : FwdRet(nullptr) {}
  ~FwdRet() override;
  explicit PROTOBUF_CONSTEXPR FwdRet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FwdRet(const FwdRet& from);
  FwdRet(FwdRet&& from) noexcept
    : FwdRet() {
    *this = ::std::move(from);
  }

  inline FwdRet& operator=(const FwdRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline FwdRet& operator=(FwdRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FwdRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const FwdRet* internal_default_instance() {
    return reinterpret_cast<const FwdRet*>(
               &_FwdRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FwdRet& a, FwdRet& b) {
    a.Swap(&b);
  }
  inline void Swap(FwdRet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FwdRet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FwdRet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FwdRet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FwdRet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FwdRet& from) {
    FwdRet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FwdRet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chain.FwdRet";
  }
  protected:
  explicit FwdRet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValFieldNumber = 1,
  };
  // optional string val = 1;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const std::string& val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_val();
  PROTOBUF_NODISCARD std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // @@protoc_insertion_point(class_scope:chain.FwdRet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chain_2eproto;
};
// -------------------------------------------------------------------

class AckArg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chain.AckArg) */ {
 public:
  inline AckArg() : AckArg(nullptr) {}
  ~AckArg() override;
  explicit PROTOBUF_CONSTEXPR AckArg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckArg(const AckArg& from);
  AckArg(AckArg&& from) noexcept
    : AckArg() {
    *this = ::std::move(from);
  }

  inline AckArg& operator=(const AckArg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckArg& operator=(AckArg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckArg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckArg* internal_default_instance() {
    return reinterpret_cast<const AckArg*>(
               &_AckArg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AckArg& a, AckArg& b) {
    a.Swap(&b);
  }
  inline void Swap(AckArg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckArg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckArg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckArg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AckArg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AckArg& from) {
    AckArg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckArg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chain.AckArg";
  }
  protected:
  explicit AckArg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:chain.AckArg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chain_2eproto;
};
// -------------------------------------------------------------------

class AckRet final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:chain.AckRet) */ {
 public:
  inline AckRet() : AckRet(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AckRet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckRet(const AckRet& from);
  AckRet(AckRet&& from) noexcept
    : AckRet() {
    *this = ::std::move(from);
  }

  inline AckRet& operator=(const AckRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckRet& operator=(AckRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckRet* internal_default_instance() {
    return reinterpret_cast<const AckRet*>(
               &_AckRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AckRet& a, AckRet& b) {
    a.Swap(&b);
  }
  inline void Swap(AckRet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckRet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckRet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckRet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AckRet& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AckRet& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chain.AckRet";
  }
  protected:
  explicit AckRet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chain.AckRet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_chain_2eproto;
};
// -------------------------------------------------------------------

class GetArg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chain.GetArg) */ {
 public:
  inline GetArg() : GetArg(nullptr) {}
  ~GetArg() override;
  explicit PROTOBUF_CONSTEXPR GetArg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetArg(const GetArg& from);
  GetArg(GetArg&& from) noexcept
    : GetArg() {
    *this = ::std::move(from);
  }

  inline GetArg& operator=(const GetArg& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetArg& operator=(GetArg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetArg& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetArg* internal_default_instance() {
    return reinterpret_cast<const GetArg*>(
               &_GetArg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetArg& a, GetArg& b) {
    a.Swap(&b);
  }
  inline void Swap(GetArg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetArg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetArg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetArg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetArg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetArg& from) {
    GetArg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chain.GetArg";
  }
  protected:
  explicit GetArg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:chain.GetArg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chain_2eproto;
};
// -------------------------------------------------------------------

class GetRet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chain.GetRet) */ {
 public:
  inline GetRet() : GetRet(nullptr) {}
  ~GetRet() override;
  explicit PROTOBUF_CONSTEXPR GetRet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRet(const GetRet& from);
  GetRet(GetRet&& from) noexcept
    : GetRet() {
    *this = ::std::move(from);
  }

  inline GetRet& operator=(const GetRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRet& operator=(GetRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRet* internal_default_instance() {
    return reinterpret_cast<const GetRet*>(
               &_GetRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetRet& a, GetRet& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetRet& from) {
    GetRet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chain.GetRet";
  }
  protected:
  explicit GetRet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
  };
  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:chain.GetRet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chain_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PutArg

// optional string key = 1;
inline bool PutArg::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PutArg::has_key() const {
  return _internal_has_key();
}
inline void PutArg::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PutArg::key() const {
  // @@protoc_insertion_point(field_get:chain.PutArg.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutArg::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chain.PutArg.key)
}
inline std::string* PutArg::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:chain.PutArg.key)
  return _s;
}
inline const std::string& PutArg::_internal_key() const {
  return _impl_.key_.Get();
}
inline void PutArg::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* PutArg::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* PutArg::release_key() {
  // @@protoc_insertion_point(field_release:chain.PutArg.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PutArg::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chain.PutArg.key)
}

// optional string val = 2;
inline bool PutArg::_internal_has_val() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PutArg::has_val() const {
  return _internal_has_val();
}
inline void PutArg::clear_val() {
  _impl_.val_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PutArg::val() const {
  // @@protoc_insertion_point(field_get:chain.PutArg.val)
  return _internal_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutArg::set_val(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.val_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chain.PutArg.val)
}
inline std::string* PutArg::mutable_val() {
  std::string* _s = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:chain.PutArg.val)
  return _s;
}
inline const std::string& PutArg::_internal_val() const {
  return _impl_.val_.Get();
}
inline void PutArg::_internal_set_val(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.val_.Set(value, GetArenaForAllocation());
}
inline std::string* PutArg::_internal_mutable_val() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.val_.Mutable(GetArenaForAllocation());
}
inline std::string* PutArg::release_val() {
  // @@protoc_insertion_point(field_release:chain.PutArg.val)
  if (!_internal_has_val()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.val_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PutArg::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.val_.SetAllocated(val, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chain.PutArg.val)
}

// optional string source_ip = 3;
inline bool PutArg::_internal_has_source_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PutArg::has_source_ip() const {
  return _internal_has_source_ip();
}
inline void PutArg::clear_source_ip() {
  _impl_.source_ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PutArg::source_ip() const {
  // @@protoc_insertion_point(field_get:chain.PutArg.source_ip)
  return _internal_source_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutArg::set_source_ip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.source_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chain.PutArg.source_ip)
}
inline std::string* PutArg::mutable_source_ip() {
  std::string* _s = _internal_mutable_source_ip();
  // @@protoc_insertion_point(field_mutable:chain.PutArg.source_ip)
  return _s;
}
inline const std::string& PutArg::_internal_source_ip() const {
  return _impl_.source_ip_.Get();
}
inline void PutArg::_internal_set_source_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.source_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* PutArg::_internal_mutable_source_ip() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.source_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* PutArg::release_source_ip() {
  // @@protoc_insertion_point(field_release:chain.PutArg.source_ip)
  if (!_internal_has_source_ip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.source_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_ip_.IsDefault()) {
    _impl_.source_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PutArg::set_allocated_source_ip(std::string* source_ip) {
  if (source_ip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.source_ip_.SetAllocated(source_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_ip_.IsDefault()) {
    _impl_.source_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chain.PutArg.source_ip)
}

// -------------------------------------------------------------------

// PutRet

// optional string val = 1;
inline bool PutRet::_internal_has_val() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PutRet::has_val() const {
  return _internal_has_val();
}
inline void PutRet::clear_val() {
  _impl_.val_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PutRet::val() const {
  // @@protoc_insertion_point(field_get:chain.PutRet.val)
  return _internal_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutRet::set_val(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.val_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chain.PutRet.val)
}
inline std::string* PutRet::mutable_val() {
  std::string* _s = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:chain.PutRet.val)
  return _s;
}
inline const std::string& PutRet::_internal_val() const {
  return _impl_.val_.Get();
}
inline void PutRet::_internal_set_val(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.val_.Set(value, GetArenaForAllocation());
}
inline std::string* PutRet::_internal_mutable_val() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.val_.Mutable(GetArenaForAllocation());
}
inline std::string* PutRet::release_val() {
  // @@protoc_insertion_point(field_release:chain.PutRet.val)
  if (!_internal_has_val()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.val_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PutRet::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.val_.SetAllocated(val, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chain.PutRet.val)
}

// -------------------------------------------------------------------

// FwdArg

// optional string key = 1;
inline bool FwdArg::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FwdArg::has_key() const {
  return _internal_has_key();
}
inline void FwdArg::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FwdArg::key() const {
  // @@protoc_insertion_point(field_get:chain.FwdArg.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FwdArg::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chain.FwdArg.key)
}
inline std::string* FwdArg::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:chain.FwdArg.key)
  return _s;
}
inline const std::string& FwdArg::_internal_key() const {
  return _impl_.key_.Get();
}
inline void FwdArg::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* FwdArg::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* FwdArg::release_key() {
  // @@protoc_insertion_point(field_release:chain.FwdArg.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FwdArg::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chain.FwdArg.key)
}

// optional string val = 2;
inline bool FwdArg::_internal_has_val() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FwdArg::has_val() const {
  return _internal_has_val();
}
inline void FwdArg::clear_val() {
  _impl_.val_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FwdArg::val() const {
  // @@protoc_insertion_point(field_get:chain.FwdArg.val)
  return _internal_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FwdArg::set_val(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.val_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chain.FwdArg.val)
}
inline std::string* FwdArg::mutable_val() {
  std::string* _s = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:chain.FwdArg.val)
  return _s;
}
inline const std::string& FwdArg::_internal_val() const {
  return _impl_.val_.Get();
}
inline void FwdArg::_internal_set_val(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.val_.Set(value, GetArenaForAllocation());
}
inline std::string* FwdArg::_internal_mutable_val() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.val_.Mutable(GetArenaForAllocation());
}
inline std::string* FwdArg::release_val() {
  // @@protoc_insertion_point(field_release:chain.FwdArg.val)
  if (!_internal_has_val()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.val_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FwdArg::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.val_.SetAllocated(val, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chain.FwdArg.val)
}

// optional string source_ip = 3;
inline bool FwdArg::_internal_has_source_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FwdArg::has_source_ip() const {
  return _internal_has_source_ip();
}
inline void FwdArg::clear_source_ip() {
  _impl_.source_ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FwdArg::source_ip() const {
  // @@protoc_insertion_point(field_get:chain.FwdArg.source_ip)
  return _internal_source_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FwdArg::set_source_ip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.source_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chain.FwdArg.source_ip)
}
inline std::string* FwdArg::mutable_source_ip() {
  std::string* _s = _internal_mutable_source_ip();
  // @@protoc_insertion_point(field_mutable:chain.FwdArg.source_ip)
  return _s;
}
inline const std::string& FwdArg::_internal_source_ip() const {
  return _impl_.source_ip_.Get();
}
inline void FwdArg::_internal_set_source_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.source_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* FwdArg::_internal_mutable_source_ip() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.source_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* FwdArg::release_source_ip() {
  // @@protoc_insertion_point(field_release:chain.FwdArg.source_ip)
  if (!_internal_has_source_ip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.source_ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_ip_.IsDefault()) {
    _impl_.source_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FwdArg::set_allocated_source_ip(std::string* source_ip) {
  if (source_ip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.source_ip_.SetAllocated(source_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_ip_.IsDefault()) {
    _impl_.source_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chain.FwdArg.source_ip)
}

// -------------------------------------------------------------------

// FwdRet

// optional string val = 1;
inline bool FwdRet::_internal_has_val() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FwdRet::has_val() const {
  return _internal_has_val();
}
inline void FwdRet::clear_val() {
  _impl_.val_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FwdRet::val() const {
  // @@protoc_insertion_point(field_get:chain.FwdRet.val)
  return _internal_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FwdRet::set_val(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.val_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chain.FwdRet.val)
}
inline std::string* FwdRet::mutable_val() {
  std::string* _s = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:chain.FwdRet.val)
  return _s;
}
inline const std::string& FwdRet::_internal_val() const {
  return _impl_.val_.Get();
}
inline void FwdRet::_internal_set_val(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.val_.Set(value, GetArenaForAllocation());
}
inline std::string* FwdRet::_internal_mutable_val() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.val_.Mutable(GetArenaForAllocation());
}
inline std::string* FwdRet::release_val() {
  // @@protoc_insertion_point(field_release:chain.FwdRet.val)
  if (!_internal_has_val()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.val_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FwdRet::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.val_.SetAllocated(val, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.val_.IsDefault()) {
    _impl_.val_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chain.FwdRet.val)
}

// -------------------------------------------------------------------

// AckArg

// optional string key = 1;
inline bool AckArg::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AckArg::has_key() const {
  return _internal_has_key();
}
inline void AckArg::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AckArg::key() const {
  // @@protoc_insertion_point(field_get:chain.AckArg.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AckArg::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chain.AckArg.key)
}
inline std::string* AckArg::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:chain.AckArg.key)
  return _s;
}
inline const std::string& AckArg::_internal_key() const {
  return _impl_.key_.Get();
}
inline void AckArg::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* AckArg::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* AckArg::release_key() {
  // @@protoc_insertion_point(field_release:chain.AckArg.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AckArg::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chain.AckArg.key)
}

// -------------------------------------------------------------------

// AckRet

// -------------------------------------------------------------------

// GetArg

// optional string key = 1;
inline bool GetArg::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetArg::has_key() const {
  return _internal_has_key();
}
inline void GetArg::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetArg::key() const {
  // @@protoc_insertion_point(field_get:chain.GetArg.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetArg::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chain.GetArg.key)
}
inline std::string* GetArg::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:chain.GetArg.key)
  return _s;
}
inline const std::string& GetArg::_internal_key() const {
  return _impl_.key_.Get();
}
inline void GetArg::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* GetArg::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* GetArg::release_key() {
  // @@protoc_insertion_point(field_release:chain.GetArg.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetArg::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chain.GetArg.key)
}

// -------------------------------------------------------------------

// GetRet

// optional string value = 2;
inline bool GetRet::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetRet::has_value() const {
  return _internal_has_value();
}
inline void GetRet::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetRet::value() const {
  // @@protoc_insertion_point(field_get:chain.GetRet.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRet::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chain.GetRet.value)
}
inline std::string* GetRet::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:chain.GetRet.value)
  return _s;
}
inline const std::string& GetRet::_internal_value() const {
  return _impl_.value_.Get();
}
inline void GetRet::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* GetRet::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* GetRet::release_value() {
  // @@protoc_insertion_point(field_release:chain.GetRet.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetRet::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chain.GetRet.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chain

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chain_2eproto
